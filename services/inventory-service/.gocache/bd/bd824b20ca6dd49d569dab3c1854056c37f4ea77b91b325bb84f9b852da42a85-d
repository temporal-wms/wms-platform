//line /Users/claudioed/development/github/temporal-war/wms-platform/services/inventory-service/internal/application/inventory_query_service.go:1:1
package application

import (
	"context"

	"github.com/wms-platform/inventory-service/internal/infrastructure/projections"
	"github.com/wms-platform/shared/pkg/logging"
)

// InventoryQueryService handles read-only queries using the CQRS read model
// This is separated from InventoryService (write side)
type InventoryQueryService struct {
	projectionRepo projections.InventoryListProjectionRepository
	logger         *logging.Logger
}

// NewInventoryQueryService creates a new query service
func NewInventoryQueryService(
	projectionRepo projections.InventoryListProjectionRepository,
	logger *logging.Logger,
) *InventoryQueryService {goCover_2976003b2855__11[0] = 1 ; goCover_2976003b2855__11[1] = goCover_2976003b2855_P ; goCover_2976003b2855__11[2] = 11 ; goCover_2976003b2855__11[3] = 1;
	return &InventoryQueryService{
		projectionRepo: projectionRepo,
		logger:         logger,
	}
}

// PagedInventoryResult represents a paginated list of inventory items
type PagedInventoryResult struct {
	Data    []InventoryListDTO `json:"data"`
	Total   int64              `json:"total"`
	Limit   int                `json:"limit"`
	Offset  int                `json:"offset"`
	HasMore bool               `json:"hasMore"`
}

// ListInventory queries inventory using the read model (fast, denormalized)
func (s *InventoryQueryService) ListInventory(ctx context.Context, query ListInventoryQuery) (*PagedInventoryResult, error) {goCover_2976003b2855__12[0] = 11 ; goCover_2976003b2855__12[1] = goCover_2976003b2855_P ; goCover_2976003b2855__12[2] = 12 ; goCover_2976003b2855__12[3] = 1;
	// Convert query to projection filter
	filter := projections.InventoryListFilter{
		SKU:             query.SKU,
		ProductName:     query.ProductName,
		SearchTerm:      query.SearchTerm,
		IsLowStock:      query.IsLowStock,
		IsOutOfStock:    query.IsOutOfStock,
		MinQuantity:     query.MinQuantity,
		MaxQuantity:     query.MaxQuantity,
		HasReservations: query.HasReservations,
		LocationID:      query.LocationID,
		Zone:            query.Zone,
	}

	// Pagination
	page := projections.Pagination{
		Limit:     query.Limit,
		Offset:    query.Offset,
		SortBy:    query.SortBy,
		SortOrder: query.SortOrder,
	}

	// Set defaults
	if page.Limit == 0 {goCover_2976003b2855__12[9] = 1;
		page.Limit = 50
	}
	goCover_2976003b2855__12[4] = 1;if page.SortBy == "" {goCover_2976003b2855__12[10] = 1;
		page.SortBy = "updatedAt"
	}
	goCover_2976003b2855__12[5] = 1;if page.SortOrder == "" {goCover_2976003b2855__12[11] = 1;
		page.SortOrder = "desc"
	}

	// Query projections
	goCover_2976003b2855__12[6] = 1;result, err := s.projectionRepo.FindWithFilter(ctx, filter, page)
	if err != nil {goCover_2976003b2855__12[12] = 1;
		s.logger.Error("Failed to query inventory projections", "error", err)
		return nil, err
	}

	// Convert projections to DTOs
	goCover_2976003b2855__12[7] = 1;dtos := make([]InventoryListDTO, len(result.Items))
	for i, proj := range result.Items {goCover_2976003b2855__12[13] = 1;
		dtos[i] = s.projectionToDTO(&proj)
	}

	goCover_2976003b2855__12[8] = 1;return &PagedInventoryResult{
		Data:    dtos,
		Total:   result.Total,
		Limit:   result.Limit,
		Offset:  result.Offset,
		HasMore: result.HasMore,
	}, nil
}

// GetInventorySummary retrieves a single inventory summary (from read model)
func (s *InventoryQueryService) GetInventorySummary(ctx context.Context, sku string) (*InventoryListDTO, error) {goCover_2976003b2855__13[0] = 5 ; goCover_2976003b2855__13[1] = goCover_2976003b2855_P ; goCover_2976003b2855__13[2] = 13 ; goCover_2976003b2855__13[3] = 1;
	projection, err := s.projectionRepo.FindBySKU(ctx, sku)
	if err != nil {goCover_2976003b2855__13[6] = 1;
		s.logger.Error("Failed to get inventory projection", "sku", sku, "error", err)
		return nil, err
	}

	goCover_2976003b2855__13[4] = 1;if projection == nil {goCover_2976003b2855__13[7] = 1;
		return nil, nil
	}

	goCover_2976003b2855__13[5] = 1;dto := s.projectionToDTO(projection)
	return &dto, nil
}

// GetLowStockItems retrieves items with low stock
func (s *InventoryQueryService) GetLowStockItems(ctx context.Context, limit, offset int) (*PagedInventoryResult, error) {goCover_2976003b2855__14[0] = 1 ; goCover_2976003b2855__14[1] = goCover_2976003b2855_P ; goCover_2976003b2855__14[2] = 14 ; goCover_2976003b2855__14[3] = 1;
	isLowStock := true
	query := ListInventoryQuery{
		IsLowStock: &isLowStock,
		Limit:      limit,
		Offset:     offset,
		SortBy:     "availableQuantity",
		SortOrder:  "asc",
	}

	return s.ListInventory(ctx, query)
}

// GetOutOfStockItems retrieves items that are out of stock
func (s *InventoryQueryService) GetOutOfStockItems(ctx context.Context, limit, offset int) (*PagedInventoryResult, error) {goCover_2976003b2855__15[0] = 1 ; goCover_2976003b2855__15[1] = goCover_2976003b2855_P ; goCover_2976003b2855__15[2] = 15 ; goCover_2976003b2855__15[3] = 1;
	isOutOfStock := true
	query := ListInventoryQuery{
		IsOutOfStock: &isOutOfStock,
		Limit:        limit,
		Offset:       offset,
		SortBy:       "updatedAt",
		SortOrder:    "desc",
	}

	return s.ListInventory(ctx, query)
}

// GetInventoryByLocation retrieves all inventory at a specific location
func (s *InventoryQueryService) GetInventoryByLocation(ctx context.Context, locationID string, limit, offset int) (*PagedInventoryResult, error) {goCover_2976003b2855__16[0] = 1 ; goCover_2976003b2855__16[1] = goCover_2976003b2855_P ; goCover_2976003b2855__16[2] = 16 ; goCover_2976003b2855__16[3] = 1;
	query := ListInventoryQuery{
		LocationID: &locationID,
		Limit:      limit,
		Offset:     offset,
		SortBy:     "availableQuantity",
		SortOrder:  "desc",
	}

	return s.ListInventory(ctx, query)
}

// CountInventoryByStatus counts inventory items matching criteria
func (s *InventoryQueryService) CountInventoryByStatus(ctx context.Context, isLowStock, isOutOfStock *bool) (int64, error) {goCover_2976003b2855__17[0] = 3 ; goCover_2976003b2855__17[1] = goCover_2976003b2855_P ; goCover_2976003b2855__17[2] = 17 ; goCover_2976003b2855__17[3] = 1;
	filter := projections.InventoryListFilter{
		IsLowStock:   isLowStock,
		IsOutOfStock: isOutOfStock,
	}

	count, err := s.projectionRepo.Count(ctx, filter)
	if err != nil {goCover_2976003b2855__17[5] = 1;
		s.logger.Error("Failed to count inventory", "error", err)
		return 0, err
	}

	goCover_2976003b2855__17[4] = 1;return count, nil
}

// Helper: Convert projection to DTO
func (s *InventoryQueryService) projectionToDTO(proj *projections.InventoryListProjection) InventoryListDTO {goCover_2976003b2855__18[0] = 1 ; goCover_2976003b2855__18[1] = goCover_2976003b2855_P ; goCover_2976003b2855__18[2] = 18 ; goCover_2976003b2855__18[3] = 1;
	return InventoryListDTO{
		SKU:                proj.SKU,
		ProductName:        proj.ProductName,
		TotalQuantity:      proj.TotalQuantity,
		ReservedQuantity:   proj.ReservedQuantity,
		AvailableQuantity:  proj.AvailableQuantity,
		ReorderPoint:       proj.ReorderPoint,
		ReorderQuantity:    proj.ReorderQuantity,
		IsLowStock:         proj.IsLowStock,
		IsOutOfStock:       proj.IsOutOfStock,
		LocationCount:      proj.LocationCount,
		PrimaryLocation:    proj.PrimaryLocation,
		AvailableLocations: proj.AvailableLocations,
		ActiveReservations: proj.ActiveReservations,
		ReservedOrders:     proj.ReservedOrders,
	}
}
