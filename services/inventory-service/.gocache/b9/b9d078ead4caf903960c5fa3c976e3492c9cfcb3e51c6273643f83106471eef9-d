//line /Users/claudioed/development/github/temporal-war/wms-platform/services/inventory-service/internal/domain/inventory_refactored.go:1:1
package domain

import (
	"errors"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// InventoryItemRefactored is the optimized aggregate root without unbounded arrays
// This version stores only the current state and computed totals
// Historical data (transactions, reservations, allocations) are stored in separate collections
type InventoryItemRefactored struct {
	ID          primitive.ObjectID `bson:"_id,omitempty"`
	SKU         string             `bson:"sku"`
	ProductName string             `bson:"productName"`

	// Multi-tenant fields for 3PL/FBA-style operations
	TenantID    string `bson:"tenantId" json:"tenantId"`
	FacilityID  string `bson:"facilityId" json:"facilityId"`
	WarehouseID string `bson:"warehouseId" json:"warehouseId"`
	SellerID    string `bson:"sellerId,omitempty" json:"sellerId,omitempty"`

	Locations             []StockLocation `bson:"locations"`
	TotalQuantity         int             `bson:"totalQuantity"`
	ReservedQuantity      int             `bson:"reservedQuantity"`      // Count only, no array
	HardAllocatedQuantity int             `bson:"hardAllocatedQuantity"` // Count only, no array
	AvailableQuantity     int             `bson:"availableQuantity"`
	ReorderPoint          int             `bson:"reorderPoint"`
	ReorderQuantity       int             `bson:"reorderQuantity"`

	// Velocity and storage fields (Amazon-style optimization)
	VelocityClass   VelocityClass   `bson:"velocityClass" json:"velocityClass"`
	StorageStrategy StorageStrategy `bson:"storageStrategy" json:"storageStrategy"`
	PickFrequency   int             `bson:"pickFrequency" json:"pickFrequency"`
	LastStowedAt    *time.Time      `bson:"lastStowedAt,omitempty" json:"lastStowedAt,omitempty"`
	LastPickedAt    *time.Time      `bson:"lastPickedAt,omitempty" json:"lastPickedAt,omitempty"`
	LastCycleCount  *time.Time      `bson:"lastCycleCount,omitempty"`

	CreatedAt    time.Time     `bson:"createdAt"`
	UpdatedAt    time.Time     `bson:"updatedAt"`
	DomainEvents []DomainEvent `bson:"-"`
}

// NewInventoryItemRefactored creates a new optimized InventoryItem aggregate
func NewInventoryItemRefactored(sku, productName string, reorderPoint, reorderQty int, tenant *InventoryTenantInfo) *InventoryItemRefactored {goCover_4dfb824e56d3__68[0] = 4 ; goCover_4dfb824e56d3__68[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__68[2] = 68 ; goCover_4dfb824e56d3__68[3] = 1;
	now := time.Now()
	item := &InventoryItemRefactored{
		SKU:                   sku,
		ProductName:           productName,
		Locations:             make([]StockLocation, 0),
		TotalQuantity:         0,
		ReservedQuantity:      0,
		HardAllocatedQuantity: 0,
		AvailableQuantity:     0,
		ReorderPoint:          reorderPoint,
		ReorderQuantity:       reorderQty,
		CreatedAt:             now,
		UpdatedAt:             now,
		DomainEvents:          make([]DomainEvent, 0),
	}

	if tenant != nil {goCover_4dfb824e56d3__68[5] = 1;
		item.TenantID = tenant.TenantID
		item.FacilityID = tenant.FacilityID
		item.WarehouseID = tenant.WarehouseID
		item.SellerID = tenant.SellerID
	} else{ goCover_4dfb824e56d3__68[6] = 1;{
		item.TenantID = "DEFAULT_TENANT"
		item.FacilityID = "DEFAULT_FACILITY"
		item.WarehouseID = "DEFAULT_WAREHOUSE"
	}}

	goCover_4dfb824e56d3__68[4] = 1;return item
}

// ReceiveStock adds stock to a location (no transaction array)
func (i *InventoryItemRefactored) ReceiveStock(locationID, zone string, quantity int) error {goCover_4dfb824e56d3__69[0] = 8 ; goCover_4dfb824e56d3__69[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__69[2] = 69 ; goCover_4dfb824e56d3__69[3] = 1;
	if quantity <= 0 {goCover_4dfb824e56d3__69[7] = 1;
		return ErrInvalidQuantity
	}

	// Find or create location
	goCover_4dfb824e56d3__69[4] = 1;found := false
	for idx := range i.Locations {goCover_4dfb824e56d3__69[8] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__69[9] = 1;
			i.Locations[idx].Quantity += quantity
			i.Locations[idx].Available += quantity
			found = true
			break
		}
	}

	goCover_4dfb824e56d3__69[5] = 1;if !found {goCover_4dfb824e56d3__69[10] = 1;
		i.Locations = append(i.Locations, StockLocation{
			LocationID: locationID,
			Zone:       zone,
			Quantity:   quantity,
			Available:  quantity,
		})
	}

	goCover_4dfb824e56d3__69[6] = 1;i.TotalQuantity += quantity
	i.AvailableQuantity += quantity
	i.UpdatedAt = time.Now()

	// Emit event (transaction will be stored separately)
	i.AddDomainEvent(&InventoryReceivedEvent{
		SKU:        i.SKU,
		Quantity:   quantity,
		LocationID: locationID,
		ReceivedAt: time.Now(),
	})

	return nil
}

// ReserveStock reserves stock for an order (updates counters only)
// Actual reservation record is created separately in inventory_reservations collection
func (i *InventoryItemRefactored) ReserveStock(locationID string, quantity int) error {goCover_4dfb824e56d3__70[0] = 10 ; goCover_4dfb824e56d3__70[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__70[2] = 70 ; goCover_4dfb824e56d3__70[3] = 1;
	if quantity <= 0 {goCover_4dfb824e56d3__70[7] = 1;
		return ErrInvalidQuantity
	}

	// Check availability at location
	goCover_4dfb824e56d3__70[4] = 1;found := false
	for idx := range i.Locations {goCover_4dfb824e56d3__70[8] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__70[9] = 1;
			if i.Locations[idx].Available < quantity {goCover_4dfb824e56d3__70[11] = 1;
				return ErrInsufficientStock
			}

			goCover_4dfb824e56d3__70[10] = 1;i.Locations[idx].Reserved += quantity
			i.Locations[idx].Available -= quantity
			found = true
			break
		}
	}

	goCover_4dfb824e56d3__70[5] = 1;if !found {goCover_4dfb824e56d3__70[12] = 1;
		return ErrLocationNotFound
	}

	goCover_4dfb824e56d3__70[6] = 1;i.ReservedQuantity += quantity
	i.AvailableQuantity -= quantity
	i.UpdatedAt = time.Now()

	return nil
}

// ReleaseReservation releases a reservation (updates counters only)
func (i *InventoryItemRefactored) ReleaseReservation(locationID string, quantity int) error {goCover_4dfb824e56d3__71[0] = 6 ; goCover_4dfb824e56d3__71[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__71[2] = 71 ; goCover_4dfb824e56d3__71[3] = 1;
	if quantity <= 0 {goCover_4dfb824e56d3__71[6] = 1;
		return ErrInvalidQuantity
	}

	// Return stock to available
	goCover_4dfb824e56d3__71[4] = 1;for idx := range i.Locations {goCover_4dfb824e56d3__71[7] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__71[8] = 1;
			i.Locations[idx].Reserved -= quantity
			i.Locations[idx].Available += quantity
			break
		}
	}

	goCover_4dfb824e56d3__71[5] = 1;i.ReservedQuantity -= quantity
	i.AvailableQuantity += quantity
	i.UpdatedAt = time.Now()

	return nil
}

// HardAllocateStock moves reserved stock to hard allocated (staged)
func (i *InventoryItemRefactored) HardAllocateStock(locationID string, quantity int) error {goCover_4dfb824e56d3__72[0] = 8 ; goCover_4dfb824e56d3__72[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__72[2] = 72 ; goCover_4dfb824e56d3__72[3] = 1;
	if quantity <= 0 {goCover_4dfb824e56d3__72[6] = 1;
		return ErrInvalidQuantity
	}

	// Move from reserved to hard allocated
	goCover_4dfb824e56d3__72[4] = 1;for idx := range i.Locations {goCover_4dfb824e56d3__72[7] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__72[8] = 1;
			if i.Locations[idx].Reserved < quantity {goCover_4dfb824e56d3__72[10] = 1;
				return errors.New("insufficient reserved quantity")
			}

			goCover_4dfb824e56d3__72[9] = 1;i.Locations[idx].Reserved -= quantity
			i.Locations[idx].HardAllocated += quantity
			break
		}
	}

	goCover_4dfb824e56d3__72[5] = 1;i.ReservedQuantity -= quantity
	i.HardAllocatedQuantity += quantity
	i.UpdatedAt = time.Now()

	return nil
}

// ReleaseHardAllocation releases a hard allocation back to available
func (i *InventoryItemRefactored) ReleaseHardAllocation(locationID string, quantity int) error {goCover_4dfb824e56d3__73[0] = 8 ; goCover_4dfb824e56d3__73[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__73[2] = 73 ; goCover_4dfb824e56d3__73[3] = 1;
	if quantity <= 0 {goCover_4dfb824e56d3__73[6] = 1;
		return ErrInvalidQuantity
	}

	// Move from hard allocated to available
	goCover_4dfb824e56d3__73[4] = 1;for idx := range i.Locations {goCover_4dfb824e56d3__73[7] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__73[8] = 1;
			if i.Locations[idx].HardAllocated < quantity {goCover_4dfb824e56d3__73[10] = 1;
				return errors.New("insufficient hard allocated quantity")
			}

			goCover_4dfb824e56d3__73[9] = 1;i.Locations[idx].HardAllocated -= quantity
			i.Locations[idx].Available += quantity
			break
		}
	}

	goCover_4dfb824e56d3__73[5] = 1;i.HardAllocatedQuantity -= quantity
	i.AvailableQuantity += quantity
	i.UpdatedAt = time.Now()

	return nil
}

// ShipStock ships hard allocated stock (removes from inventory)
func (i *InventoryItemRefactored) ShipStock(locationID string, quantity int) error {goCover_4dfb824e56d3__74[0] = 10 ; goCover_4dfb824e56d3__74[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__74[2] = 74 ; goCover_4dfb824e56d3__74[3] = 1;
	if quantity <= 0 {goCover_4dfb824e56d3__74[7] = 1;
		return ErrInvalidQuantity
	}

	// Reduce total quantity (inventory leaves warehouse)
	goCover_4dfb824e56d3__74[4] = 1;for idx := range i.Locations {goCover_4dfb824e56d3__74[8] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__74[9] = 1;
			if i.Locations[idx].HardAllocated < quantity {goCover_4dfb824e56d3__74[11] = 1;
				return errors.New("insufficient hard allocated quantity")
			}

			goCover_4dfb824e56d3__74[10] = 1;i.Locations[idx].Quantity -= quantity
			i.Locations[idx].HardAllocated -= quantity
			break
		}
	}

	goCover_4dfb824e56d3__74[5] = 1;i.TotalQuantity -= quantity
	i.HardAllocatedQuantity -= quantity
	i.UpdatedAt = time.Now()

	// Check for low stock
	if i.AvailableQuantity <= i.ReorderPoint {goCover_4dfb824e56d3__74[12] = 1;
		i.AddDomainEvent(&LowStockAlertEvent{
			SKU:             i.SKU,
			CurrentQuantity: i.AvailableQuantity,
			ReorderPoint:    i.ReorderPoint,
			AlertedAt:       time.Now(),
		})
	}

	goCover_4dfb824e56d3__74[6] = 1;return nil
}

// AdjustStock adjusts stock quantity (for cycle counts, corrections)
func (i *InventoryItemRefactored) AdjustStock(locationID string, newQuantity int) error {goCover_4dfb824e56d3__75[0] = 4 ; goCover_4dfb824e56d3__75[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__75[2] = 75 ; goCover_4dfb824e56d3__75[3] = 1;
	for idx := range i.Locations {goCover_4dfb824e56d3__75[5] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__75[6] = 1;
			oldQty := i.Locations[idx].Quantity
			diff := newQuantity - oldQty

			i.Locations[idx].Quantity = newQuantity
			i.Locations[idx].Available = newQuantity - i.Locations[idx].Reserved - i.Locations[idx].HardAllocated
			i.TotalQuantity += diff
			i.AvailableQuantity += diff

			i.UpdatedAt = time.Now()
			return nil
		}
	}
	goCover_4dfb824e56d3__75[4] = 1;return ErrLocationNotFound
}

// RecordShortage records a confirmed stock shortage
func (i *InventoryItemRefactored) RecordShortage(locationID string, shortageQty int) error {goCover_4dfb824e56d3__76[0] = 10 ; goCover_4dfb824e56d3__76[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__76[2] = 76 ; goCover_4dfb824e56d3__76[3] = 1;
	if shortageQty <= 0 {goCover_4dfb824e56d3__76[6] = 1;
		return ErrNoShortageToRecord
	}

	goCover_4dfb824e56d3__76[4] = 1;for idx := range i.Locations {goCover_4dfb824e56d3__76[7] = 1;
		if i.Locations[idx].LocationID == locationID {goCover_4dfb824e56d3__76[8] = 1;
			i.Locations[idx].Quantity -= shortageQty
			i.Locations[idx].Available -= shortageQty
			if i.Locations[idx].Available < 0 {goCover_4dfb824e56d3__76[11] = 1;
				overReserved := -i.Locations[idx].Available
				i.Locations[idx].Reserved -= overReserved
				i.Locations[idx].Available = 0
				i.ReservedQuantity -= overReserved
			}

			goCover_4dfb824e56d3__76[9] = 1;i.TotalQuantity -= shortageQty
			i.AvailableQuantity -= shortageQty
			if i.AvailableQuantity < 0 {goCover_4dfb824e56d3__76[12] = 1;
				i.AvailableQuantity = 0
			}

			goCover_4dfb824e56d3__76[10] = 1;i.UpdatedAt = time.Now()
			return nil
		}
	}
	goCover_4dfb824e56d3__76[5] = 1;return ErrLocationNotFound
}

// UpdatePickFrequency updates the pick frequency and recalculates velocity class
func (i *InventoryItemRefactored) UpdatePickFrequency(picksPerWeek int) {goCover_4dfb824e56d3__77[0] = 2 ; goCover_4dfb824e56d3__77[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__77[2] = 77 ; goCover_4dfb824e56d3__77[3] = 1;
	oldClass := i.VelocityClass
	i.PickFrequency = picksPerWeek
	i.VelocityClass = i.CalculateVelocityClass()
	now := time.Now()
	i.LastPickedAt = &now
	i.UpdatedAt = now

	if oldClass != i.VelocityClass {goCover_4dfb824e56d3__77[4] = 1;
		i.AddDomainEvent(&VelocityClassChangedEvent{
			SKU:           i.SKU,
			OldClass:      string(oldClass),
			NewClass:      string(i.VelocityClass),
			PickFrequency: i.PickFrequency,
			ChangedAt:     now,
		})
	}
}

// CalculateVelocityClass determines the velocity class based on pick frequency
func (i *InventoryItemRefactored) CalculateVelocityClass() VelocityClass {goCover_4dfb824e56d3__78[0] = 5 ; goCover_4dfb824e56d3__78[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__78[2] = 78 ; goCover_4dfb824e56d3__78[3] = 1;
	if i.PickFrequency > VelocityAThreshold {goCover_4dfb824e56d3__78[5] = 1;
		return VelocityA
	} else{ goCover_4dfb824e56d3__78[6] = 1;if i.PickFrequency >= VelocityBThreshold {goCover_4dfb824e56d3__78[7] = 1;
		return VelocityB
	}}
	goCover_4dfb824e56d3__78[4] = 1;return VelocityC
}

// RecordCycleCount records a cycle count
func (i *InventoryItemRefactored) RecordCycleCount() {goCover_4dfb824e56d3__79[0] = 1 ; goCover_4dfb824e56d3__79[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__79[2] = 79 ; goCover_4dfb824e56d3__79[3] = 1;
	now := time.Now()
	i.LastCycleCount = &now
	i.UpdatedAt = now
}

// SetStorageStrategy sets the storage strategy
func (i *InventoryItemRefactored) SetStorageStrategy(strategy StorageStrategy) {goCover_4dfb824e56d3__80[0] = 2 ; goCover_4dfb824e56d3__80[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__80[2] = 80 ; goCover_4dfb824e56d3__80[3] = 1;
	if strategy.IsValid() {goCover_4dfb824e56d3__80[4] = 1;
		i.StorageStrategy = strategy
		i.UpdatedAt = time.Now()
	}
}

// RecordStow records when an item was stowed
func (i *InventoryItemRefactored) RecordStow() {goCover_4dfb824e56d3__81[0] = 1 ; goCover_4dfb824e56d3__81[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__81[2] = 81 ; goCover_4dfb824e56d3__81[3] = 1;
	now := time.Now()
	i.LastStowedAt = &now
	i.UpdatedAt = now
}

// GetLocationStock returns stock at a specific location
func (i *InventoryItemRefactored) GetLocationStock(locationID string) *StockLocation {goCover_4dfb824e56d3__82[0] = 4 ; goCover_4dfb824e56d3__82[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__82[2] = 82 ; goCover_4dfb824e56d3__82[3] = 1;
	for _, loc := range i.Locations {goCover_4dfb824e56d3__82[5] = 1;
		if loc.LocationID == locationID {goCover_4dfb824e56d3__82[6] = 1;
			return &loc
		}
	}
	goCover_4dfb824e56d3__82[4] = 1;return nil
}

// GetAvailableLocations returns locations with available stock
func (i *InventoryItemRefactored) GetAvailableLocations() []StockLocation {goCover_4dfb824e56d3__83[0] = 4 ; goCover_4dfb824e56d3__83[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__83[2] = 83 ; goCover_4dfb824e56d3__83[3] = 1;
	available := make([]StockLocation, 0)
	for _, loc := range i.Locations {goCover_4dfb824e56d3__83[5] = 1;
		if loc.Available > 0 {goCover_4dfb824e56d3__83[6] = 1;
			available = append(available, loc)
		}
	}
	goCover_4dfb824e56d3__83[4] = 1;return available
}

// Domain event methods
func (i *InventoryItemRefactored) AddDomainEvent(event DomainEvent) {goCover_4dfb824e56d3__84[0] = 1 ; goCover_4dfb824e56d3__84[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__84[2] = 84 ; goCover_4dfb824e56d3__84[3] = 1;
	i.DomainEvents = append(i.DomainEvents, event)
}

func (i *InventoryItemRefactored) ClearDomainEvents() {goCover_4dfb824e56d3__85[0] = 1 ; goCover_4dfb824e56d3__85[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__85[2] = 85 ; goCover_4dfb824e56d3__85[3] = 1;
	i.DomainEvents = make([]DomainEvent, 0)
}

func (i *InventoryItemRefactored) GetDomainEvents() []DomainEvent {goCover_4dfb824e56d3__86[0] = 1 ; goCover_4dfb824e56d3__86[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__86[2] = 86 ; goCover_4dfb824e56d3__86[3] = 1;
	return i.DomainEvents
}

// Validation methods
func (i *InventoryItemRefactored) IsHighVelocity() bool {goCover_4dfb824e56d3__87[0] = 1 ; goCover_4dfb824e56d3__87[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__87[2] = 87 ; goCover_4dfb824e56d3__87[3] = 1;
	return i.VelocityClass == VelocityA
}

func (i *InventoryItemRefactored) IsMediumVelocity() bool {goCover_4dfb824e56d3__88[0] = 1 ; goCover_4dfb824e56d3__88[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__88[2] = 88 ; goCover_4dfb824e56d3__88[3] = 1;
	return i.VelocityClass == VelocityB
}

func (i *InventoryItemRefactored) IsLowVelocity() bool {goCover_4dfb824e56d3__89[0] = 1 ; goCover_4dfb824e56d3__89[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__89[2] = 89 ; goCover_4dfb824e56d3__89[3] = 1;
	return i.VelocityClass == VelocityC
}

func (i *InventoryItemRefactored) IsLowStock() bool {goCover_4dfb824e56d3__90[0] = 1 ; goCover_4dfb824e56d3__90[1] = goCover_4dfb824e56d3_P ; goCover_4dfb824e56d3__90[2] = 90 ; goCover_4dfb824e56d3__90[3] = 1;
	return i.AvailableQuantity <= i.ReorderPoint
}
