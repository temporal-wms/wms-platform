//line /Users/claudioed/development/github/temporal-war/wms-platform/services/inventory-service/internal/infrastructure/mongodb/inventory_allocation_repository.go:1:1
package mongodb

import (
	"context"
	"fmt"
	"time"

	"github.com/wms-platform/inventory-service/internal/domain"
	"github.com/wms-platform/shared/pkg/tenant"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type InventoryAllocationRepository struct {
	collection   *mongo.Collection
	db           *mongo.Database
	tenantHelper *tenant.RepositoryHelper
}

func NewInventoryAllocationRepository(db *mongo.Database) *InventoryAllocationRepository {goCover_dfe2877813fc__0[0] = 1 ; goCover_dfe2877813fc__0[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__0[2] = 0 ; goCover_dfe2877813fc__0[3] = 1;
	collection := db.Collection("inventory_allocations")

	repo := &InventoryAllocationRepository{
		collection:   collection,
		db:           db,
		tenantHelper: tenant.NewRepositoryHelper(false),
	}
	repo.ensureIndexes(context.Background())

	return repo
}

func (r *InventoryAllocationRepository) ensureIndexes(ctx context.Context) {goCover_dfe2877813fc__1[0] = 1 ; goCover_dfe2877813fc__1[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__1[2] = 1 ; goCover_dfe2877813fc__1[3] = 1;
	indexes := []mongo.IndexModel{
		// Unique constraint on allocationId
		{
			Keys:    bson.D{{Key: "allocationId", Value: 1}},
			Options: options.Index().SetUnique(true),
		},
		// Primary lookup by SKU + status + tenant
		{Keys: bson.D{
			{Key: "tenantId", Value: 1},
			{Key: "facilityId", Value: 1},
			{Key: "sku", Value: 1},
			{Key: "status", Value: 1},
		}},
		// Lookup by order ID
		{Keys: bson.D{
			{Key: "tenantId", Value: 1},
			{Key: "facilityId", Value: 1},
			{Key: "orderId", Value: 1},
		}},
		// Lookup by reservation ID
		{Keys: bson.D{
			{Key: "reservationId", Value: 1},
		}},
		// Lookup by source location
		{Keys: bson.D{
			{Key: "tenantId", Value: 1},
			{Key: "facilityId", Value: 1},
			{Key: "sourceLocationId", Value: 1},
			{Key: "status", Value: 1},
		}},
		// Lookup by staging location
		{Keys: bson.D{
			{Key: "tenantId", Value: 1},
			{Key: "facilityId", Value: 1},
			{Key: "stagingLocationId", Value: 1},
			{Key: "status", Value: 1},
		}},
		// TTL index for old shipped/returned allocations (archive after 30 days)
		{
			Keys: bson.D{{Key: "updatedAt", Value: 1}},
			Options: options.Index().
				SetName("idx_updatedAt_ttl").
				SetPartialFilterExpression(bson.M{
					"status": bson.M{"$in": []string{"shipped", "returned"}},
				}).
				SetExpireAfterSeconds(2592000), // 30 days
		},
	}
	r.collection.Indexes().CreateMany(ctx, indexes)
}

func (r *InventoryAllocationRepository) Save(ctx context.Context, allocation *domain.InventoryAllocationAggregate) error {goCover_dfe2877813fc__2[0] = 3 ; goCover_dfe2877813fc__2[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__2[2] = 2 ; goCover_dfe2877813fc__2[3] = 1;
	opts := options.Update().SetUpsert(true)
	filter := bson.M{"allocationId": allocation.AllocationID}
	update := bson.M{"$set": allocation}

	_, err := r.collection.UpdateOne(ctx, filter, update, opts)
	if err != nil {goCover_dfe2877813fc__2[5] = 1;
		return fmt.Errorf("failed to save allocation: %w", err)
	}
	goCover_dfe2877813fc__2[4] = 1;return nil
}

func (r *InventoryAllocationRepository) FindByID(ctx context.Context, allocationID string) (*domain.InventoryAllocationAggregate, error) {goCover_dfe2877813fc__3[0] = 3 ; goCover_dfe2877813fc__3[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__3[2] = 3 ; goCover_dfe2877813fc__3[3] = 1;
	filter := bson.M{"allocationId": allocationID}
	filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	var allocation domain.InventoryAllocationAggregate
	err := r.collection.FindOne(ctx, filter).Decode(&allocation)
	if err == mongo.ErrNoDocuments {goCover_dfe2877813fc__3[5] = 1;
		return nil, nil
	}
	goCover_dfe2877813fc__3[4] = 1;return &allocation, err
}

func (r *InventoryAllocationRepository) FindByReservationID(ctx context.Context, reservationID string) (*domain.InventoryAllocationAggregate, error) {goCover_dfe2877813fc__4[0] = 3 ; goCover_dfe2877813fc__4[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__4[2] = 4 ; goCover_dfe2877813fc__4[3] = 1;
	filter := bson.M{"reservationId": reservationID}
	filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	var allocation domain.InventoryAllocationAggregate
	err := r.collection.FindOne(ctx, filter).Decode(&allocation)
	if err == mongo.ErrNoDocuments {goCover_dfe2877813fc__4[5] = 1;
		return nil, nil
	}
	goCover_dfe2877813fc__4[4] = 1;return &allocation, err
}

func (r *InventoryAllocationRepository) FindBySKU(ctx context.Context, sku string, status domain.AllocationStatus) ([]*domain.InventoryAllocationAggregate, error) {goCover_dfe2877813fc__5[0] = 5 ; goCover_dfe2877813fc__5[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__5[2] = 5 ; goCover_dfe2877813fc__5[3] = 1;
	filter := bson.M{"sku": sku}
	if status != "" {goCover_dfe2877813fc__5[6] = 1;
		filter["status"] = status
	}
	goCover_dfe2877813fc__5[4] = 1;filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	cursor, err := r.collection.Find(ctx, filter)
	if err != nil {goCover_dfe2877813fc__5[7] = 1;
		return nil, err
	}
	goCover_dfe2877813fc__5[5] = 1;defer cursor.Close(ctx)

	var allocations []*domain.InventoryAllocationAggregate
	err = cursor.All(ctx, &allocations)
	return allocations, err
}

func (r *InventoryAllocationRepository) FindByOrderID(ctx context.Context, orderID string) ([]*domain.InventoryAllocationAggregate, error) {goCover_dfe2877813fc__6[0] = 3 ; goCover_dfe2877813fc__6[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__6[2] = 6 ; goCover_dfe2877813fc__6[3] = 1;
	filter := bson.M{"orderId": orderID}
	filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	cursor, err := r.collection.Find(ctx, filter)
	if err != nil {goCover_dfe2877813fc__6[5] = 1;
		return nil, err
	}
	goCover_dfe2877813fc__6[4] = 1;defer cursor.Close(ctx)

	var allocations []*domain.InventoryAllocationAggregate
	err = cursor.All(ctx, &allocations)
	return allocations, err
}

func (r *InventoryAllocationRepository) FindByLocation(ctx context.Context, locationID string, locationType string, status domain.AllocationStatus) ([]*domain.InventoryAllocationAggregate, error) {goCover_dfe2877813fc__7[0] = 10 ; goCover_dfe2877813fc__7[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__7[2] = 7 ; goCover_dfe2877813fc__7[3] = 1;
	filter := bson.M{}

	// locationType can be "source" or "staging"
	if locationType == "source" {goCover_dfe2877813fc__7[7] = 1;
		filter["sourceLocationId"] = locationID
	} else{ goCover_dfe2877813fc__7[8] = 1;if locationType == "staging" {goCover_dfe2877813fc__7[9] = 1;
		filter["stagingLocationId"] = locationID
	} else{ goCover_dfe2877813fc__7[10] = 1;{
		// Search both
		filter["$or"] = []bson.M{
			{"sourceLocationId": locationID},
			{"stagingLocationId": locationID},
		}
	}}}

	goCover_dfe2877813fc__7[4] = 1;if status != "" {goCover_dfe2877813fc__7[11] = 1;
		filter["status"] = status
	}
	goCover_dfe2877813fc__7[5] = 1;filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	cursor, err := r.collection.Find(ctx, filter)
	if err != nil {goCover_dfe2877813fc__7[12] = 1;
		return nil, err
	}
	goCover_dfe2877813fc__7[6] = 1;defer cursor.Close(ctx)

	var allocations []*domain.InventoryAllocationAggregate
	err = cursor.All(ctx, &allocations)
	return allocations, err
}

// FindActive finds all active (staged or packed) allocations
func (r *InventoryAllocationRepository) FindActive(ctx context.Context, limit int) ([]*domain.InventoryAllocationAggregate, error) {goCover_dfe2877813fc__8[0] = 3 ; goCover_dfe2877813fc__8[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__8[2] = 8 ; goCover_dfe2877813fc__8[3] = 1;
	filter := bson.M{
		"status": bson.M{"$in": []string{string(domain.AllocationStatusStaged), string(domain.AllocationStatusPacked)}},
	}
	filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	opts := options.Find().
		SetSort(bson.D{{Key: "createdAt", Value: -1}}).
		SetLimit(int64(limit))

	cursor, err := r.collection.Find(ctx, filter, opts)
	if err != nil {goCover_dfe2877813fc__8[5] = 1;
		return nil, err
	}
	goCover_dfe2877813fc__8[4] = 1;defer cursor.Close(ctx)

	var allocations []*domain.InventoryAllocationAggregate
	err = cursor.All(ctx, &allocations)
	return allocations, err
}

// GetActiveAllocationCountBySKU returns the count of active allocations for a SKU
func (r *InventoryAllocationRepository) GetActiveAllocationCountBySKU(ctx context.Context, sku string) (int64, error) {goCover_dfe2877813fc__9[0] = 3 ; goCover_dfe2877813fc__9[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__9[2] = 9 ; goCover_dfe2877813fc__9[3] = 1;
	filter := bson.M{
		"sku":    sku,
		"status": bson.M{"$in": []string{string(domain.AllocationStatusStaged), string(domain.AllocationStatusPacked)}},
	}
	filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	count, err := r.collection.CountDocuments(ctx, filter)
	if err != nil {goCover_dfe2877813fc__9[5] = 1;
		return 0, fmt.Errorf("failed to count allocations: %w", err)
	}

	goCover_dfe2877813fc__9[4] = 1;return count, nil
}

// UpdateStatus updates the status of an allocation (bulk operation)
func (r *InventoryAllocationRepository) UpdateStatus(ctx context.Context, allocationID string, newStatus domain.AllocationStatus) error {goCover_dfe2877813fc__10[0] = 5 ; goCover_dfe2877813fc__10[1] = goCover_dfe2877813fc_P ; goCover_dfe2877813fc__10[2] = 10 ; goCover_dfe2877813fc__10[3] = 1;
	filter := bson.M{"allocationId": allocationID}
	filter = r.tenantHelper.WithTenantFilterOptional(ctx, filter)

	update := bson.M{
		"$set": bson.M{
			"status":    newStatus,
			"updatedAt": time.Now(),
		},
	}

	result, err := r.collection.UpdateOne(ctx, filter, update)
	if err != nil {goCover_dfe2877813fc__10[6] = 1;
		return fmt.Errorf("failed to update allocation status: %w", err)
	}

	goCover_dfe2877813fc__10[4] = 1;if result.MatchedCount == 0 {goCover_dfe2877813fc__10[7] = 1;
		return domain.ErrAllocationNotFound
	}

	goCover_dfe2877813fc__10[5] = 1;return nil
}
