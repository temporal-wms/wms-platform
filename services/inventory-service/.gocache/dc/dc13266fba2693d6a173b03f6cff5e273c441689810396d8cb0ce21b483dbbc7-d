//line /Users/claudioed/development/github/temporal-war/wms-platform/services/inventory-service/cmd/monitor/main.go:1:1
package main; import _ "runtime/coverage"

import (
	"context"
	"flag"
	"fmt"
	"log"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// Document size monitoring tool for inventory collection
// Alerts when documents are approaching MongoDB's 16MB limit

var (
	mongoURI  = flag.String("mongo-uri", "mongodb://localhost:27017", "MongoDB connection URI")
	dbName    = flag.String("db", "temporal_war", "Database name")
	threshold = flag.Int("threshold", 8388608, "Alert threshold in bytes (default: 8MB)")
	limit     = flag.Int("limit", 50, "Maximum number of results to display")
)

const (
	MB16 = 16777216 // 16 MB in bytes
	MB8  = 8388608  // 8 MB in bytes
	MB5  = 5242880  // 5 MB in bytes
	MB1  = 1048576  // 1 MB in bytes
)

type DocumentSizeInfo struct {
	SKU             string `bson:"sku"`
	Size            int    `bson:"size"`
	TransactionCount int    `bson:"txCount"`
	ReservationCount int    `bson:"resCount"`
	AllocationCount  int    `bson:"allocCount"`
}

func main() {goCover_f09784b27a00__0[0] = 6 ; goCover_f09784b27a00__0[1] = goCover_f09784b27a00_P ; goCover_f09784b27a00__0[2] = 0 ; goCover_f09784b27a00__0[3] = 1;
	flag.Parse()

	log.Printf("Starting document size monitoring...")
	log.Printf("MongoDB URI: %s", *mongoURI)
	log.Printf("Database: %s", *dbName)
	log.Printf("Alert Threshold: %d bytes (%.2f MB)", *threshold, float64(*threshold)/MB1)

	// Connect to MongoDB
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	client, err := mongo.Connect(ctx, options.Client().ApplyURI(*mongoURI))
	if err != nil {goCover_f09784b27a00__0[6] = 1;
		log.Fatalf("Failed to connect to MongoDB: %v", err)
	}
	goCover_f09784b27a00__0[4] = 1;defer client.Disconnect(context.Background())

	// Ping to verify connection
	if err := client.Ping(ctx, nil); err != nil {goCover_f09784b27a00__0[7] = 1;
		log.Fatalf("Failed to ping MongoDB: %v", err)
	}
	goCover_f09784b27a00__0[5] = 1;log.Println("Connected to MongoDB successfully")

	db := client.Database(*dbName)

	// Analyze inventory collection
	if err := analyzeCollection(context.Background(), db, "inventory"); err != nil {goCover_f09784b27a00__0[8] = 1;
		log.Fatalf("Analysis failed: %v", err)
	}
}

func analyzeCollection(ctx context.Context, db *mongo.Database, collectionName string) error {goCover_f09784b27a00__1[0] = 22 ; goCover_f09784b27a00__1[1] = goCover_f09784b27a00_P ; goCover_f09784b27a00__1[2] = 1 ; goCover_f09784b27a00__1[3] = 1;
	collection := db.Collection(collectionName)

	// Get document count
	totalCount, err := collection.CountDocuments(ctx, bson.M{})
	if err != nil {goCover_f09784b27a00__1[11] = 1;
		return fmt.Errorf("failed to count documents: %w", err)
	}

	goCover_f09784b27a00__1[4] = 1;fmt.Printf("\n=== Collection: %s ===\n", collectionName)
	fmt.Printf("Total Documents: %d\n\n", totalCount)

	// Aggregate pipeline to calculate document sizes and array lengths
	pipeline := []bson.M{
		{
			"$project": bson.M{
				"sku":      1,
				"size":     bson.M{"$bsonSize": "$$ROOT"},
				"txCount":  bson.M{"$size": bson.M{"$ifNull": []interface{}{"$transactions", []interface{}{}}}},
				"resCount": bson.M{"$size": bson.M{"$ifNull": []interface{}{"$reservations", []interface{}{}}}},
				"allocCount": bson.M{"$size": bson.M{"$ifNull": []interface{}{"$hardAllocations", []interface{}{}}}},
			},
		},
		{
			"$match": bson.M{
				"size": bson.M{"$gte": *threshold},
			},
		},
		{
			"$sort": bson.M{"size": -1},
		},
		{
			"$limit": int64(*limit),
		},
	}

	cursor, err := collection.Aggregate(ctx, pipeline)
	if err != nil {goCover_f09784b27a00__1[12] = 1;
		return fmt.Errorf("failed to run aggregation: %w", err)
	}
	goCover_f09784b27a00__1[5] = 1;defer cursor.Close(ctx)

	var largeDocuments []DocumentSizeInfo
	if err := cursor.All(ctx, &largeDocuments); err != nil {goCover_f09784b27a00__1[13] = 1;
		return fmt.Errorf("failed to decode results: %w", err)
	}

	// Display results
	goCover_f09784b27a00__1[6] = 1;if len(largeDocuments) == 0 {goCover_f09784b27a00__1[14] = 1;
		fmt.Println("âœ… No documents exceed the threshold")
		return nil
	}

	goCover_f09784b27a00__1[7] = 1;fmt.Printf("âš ï¸  Found %d documents exceeding %d bytes:\n\n", len(largeDocuments), *threshold)
	fmt.Println("SKU                                  Size (MB)   Transactions  Reservations  Allocations  Status")
	fmt.Println("-----------------------------------  ----------  ------------  ------------  -----------  --------")

	for _, doc := range largeDocuments {goCover_f09784b27a00__1[15] = 1;
		sizeMB := float64(doc.Size) / MB1
		status := getStatus(doc.Size)
		fmt.Printf("%-35s  %10.2f  %12d  %12d  %11d  %s\n",
			doc.SKU,
			sizeMB,
			doc.TransactionCount,
			doc.ReservationCount,
			doc.AllocationCount,
			status,
		)
	}

	// Distribution analysis
	goCover_f09784b27a00__1[8] = 1;fmt.Println("\n=== Size Distribution ===")
	if err := analyzeSizeDistribution(ctx, collection); err != nil {goCover_f09784b27a00__1[16] = 1;
		log.Printf("WARNING: Failed to analyze distribution: %v", err)
	}

	// Recommendations
	goCover_f09784b27a00__1[9] = 1;fmt.Println("\n=== Recommendations ===")
	for _, doc := range largeDocuments {goCover_f09784b27a00__1[17] = 1;
		if doc.Size > MB8 {goCover_f09784b27a00__1[18] = 1;
			fmt.Printf("ðŸš¨ CRITICAL: SKU %s (%0.2f MB)\n", doc.SKU, float64(doc.Size)/MB1)
			if doc.TransactionCount > 1000 {goCover_f09784b27a00__1[22] = 1;
				fmt.Printf("   - %d transactions: Consider archiving to inventory_transactions collection\n", doc.TransactionCount)
			}
			goCover_f09784b27a00__1[19] = 1;if doc.ReservationCount > 100 {goCover_f09784b27a00__1[23] = 1;
				fmt.Printf("   - %d reservations: Consider moving to inventory_reservations collection\n", doc.ReservationCount)
			}
			goCover_f09784b27a00__1[20] = 1;if doc.AllocationCount > 100 {goCover_f09784b27a00__1[24] = 1;
				fmt.Printf("   - %d allocations: Consider moving to inventory_allocations collection\n", doc.AllocationCount)
			}
			goCover_f09784b27a00__1[21] = 1;fmt.Println()
		}
	}

	goCover_f09784b27a00__1[10] = 1;return nil
}

func analyzeSizeDistribution(ctx context.Context, collection *mongo.Collection) error {goCover_f09784b27a00__2[0] = 13 ; goCover_f09784b27a00__2[1] = goCover_f09784b27a00_P ; goCover_f09784b27a00__2[2] = 2 ; goCover_f09784b27a00__2[3] = 1;
	pipeline := []bson.M{
		{
			"$project": bson.M{
				"size": bson.M{"$bsonSize": "$$ROOT"},
			},
		},
		{
			"$bucket": bson.M{
				"groupBy": "$size",
				"boundaries": []int{
					0,
					MB1,    // 1MB
					MB5,    // 5MB
					MB8,    // 8MB
					MB16,   // 16MB
				},
				"default": "16MB+",
				"output": bson.M{
					"count": bson.M{"$sum": 1},
				},
			},
		},
	}

	cursor, err := collection.Aggregate(ctx, pipeline)
	if err != nil {goCover_f09784b27a00__2[7] = 1;
		return err
	}
	goCover_f09784b27a00__2[4] = 1;defer cursor.Close(ctx)

	type BucketResult struct {
		ID    interface{} `bson:"_id"`
		Count int         `bson:"count"`
	}

	var results []BucketResult
	if err := cursor.All(ctx, &results); err != nil {goCover_f09784b27a00__2[8] = 1;
		return err
	}

	goCover_f09784b27a00__2[5] = 1;for _, result := range results {goCover_f09784b27a00__2[9] = 1;
		var label string
		switch result.ID {
		case 0:goCover_f09784b27a00__2[11] = 1;
			label = "0-1 MB"
		case MB1:goCover_f09784b27a00__2[12] = 1;
			label = "1-5 MB"
		case MB5:goCover_f09784b27a00__2[13] = 1;
			label = "5-8 MB"
		case MB8:goCover_f09784b27a00__2[14] = 1;
			label = "8-16 MB"
		default:goCover_f09784b27a00__2[15] = 1;
			label = fmt.Sprintf("%v", result.ID)
		}
		goCover_f09784b27a00__2[10] = 1;fmt.Printf("  %s: %d documents\n", label, result.Count)
	}

	goCover_f09784b27a00__2[6] = 1;return nil
}

func getStatus(size int) string {goCover_f09784b27a00__3[0] = 7 ; goCover_f09784b27a00__3[1] = goCover_f09784b27a00_P ; goCover_f09784b27a00__3[2] = 3 ; goCover_f09784b27a00__3[3] = 1;
	if size >= 12*MB1 {goCover_f09784b27a00__3[5] = 1;
		return "ðŸ”´ URGENT"
	} else{ goCover_f09784b27a00__3[6] = 1;if size >= MB8 {goCover_f09784b27a00__3[7] = 1;
		return "ðŸŸ  WARNING"
	} else{ goCover_f09784b27a00__3[8] = 1;if size >= MB5 {goCover_f09784b27a00__3[9] = 1;
		return "ðŸŸ¡ CAUTION"
	}}}
	goCover_f09784b27a00__3[4] = 1;return "ðŸŸ¢ OK"
}
